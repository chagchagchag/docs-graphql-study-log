{"/":{"title":"Introduction","data":{"":"GraphQL\nGraphQL 개념\nSpring For GraphQL\n기회가 된다면... Node.js 에서 GraphQL 을 사용하는 방법도 try 해본과정을 문서화하기로 결정"}},"/what-is-graphql/graphql-summary":{"title":"GraphQL","data":{"참고자료#참고자료":"공식 자료\ngraphql-kr.github.io\ngraphql-kr.github.io/learn\n블로그\nhttps://hahahoho5915.tistory.com/63\nhttps://tech.kakao.com/posts/364\nhttps://ivvve.github.io/2019/07/24/server/graphql/over-under-fetching/\nhttps://ziszini.tistory.com/154","등장배경-fql-graphql-todo#등장배경, FQL, GraphQL (todo)":"이 부분은 책의 개념을 더 자세히 보고 정리 예정","등장-배경#등장 배경":"GraphQL, FQL 이 나타나게 된 것은 REST API 의 단점을 극복하기 위해 나타나게 되었습니다.흔히 알려진 REST API 의 단점은 아래와 같습니다.\nover-fetching : API 호출 시 필요한 것 보다 더 많은 데이터를 가져오는 것을 의미합니다.\nunder-fetching : Endpoint 하나로부터 충분한 데이터를 받지 못해 두개 이상의 Endpoint 에 요청을 해야 하는 것을 의미합니다.\n복수의 엔드포인트 관리 : 클라이언트 측에서는 유사한 데이터를 가지고 있지만 조금씩 다른 엔드포인트 등과 같은 여러개의 API 엔드포인트를 관리해야 했습니다.","fql#FQL":"이런 REST API 의 한계를 극복하고자 Facebook 에서 FQL 이라고 하는 것을 만들었는데 SQL 과 유사한 문법을 가졌으며 소셜데이터에 최적화 되어있었습니다. 하지만, FQL 은 복잡하고 제한적이며 유연성이 부족하다는 단점이 있었고 개발 및 지원이 종료되었습니다.","graphql#GraphQL":"타입시스템을 사용하며 강력한 쿼리 언어를 갖습니다.\n효율적인 데이터 로딩, 캐싱을 지원합니다.\n단일 엔드 포인트를 사용합니다.\nREST API 에서는 복수개의 엔드포인트를 관리하는데, GraphQL 에서는 단일 엔드포인트를 관리합니다.\n단점으로는 아래와 같은 점들이 있습니다.\n고정된 요청, 고정된 응답만 할 때는 query 로 인해 요청의 크기가 REST API 보다 커질 수 있습니다.\n캐싱이 REST 보다 복잡합니다.\n파일 업로드 구현 방법이 정해져있지 않기에 직접 구현해야 합니다.\nGraphQL 은 완벽하게 REST API 를 대체하지는 못합니다. REST 에 적합한 서비스에는 REST 가 사용되는 것이 더 바람직합니다. 즉, 꼭 필요한 케이스를 파악해서 필요한 경우에만 GraphQL 을 사용하는 것이 권장됩니다.","graphql-의-장점#GraphQL 의 장점":"","클라이언트-중심의-query#클라이언트 중심의 Query":"예를 들어 Client 에서 아래와 같은 형태의 쿼리를 보냈다고 해보겠습니다.\n{\r\n    user(id: 333){\r\n        id\r\n        name\r\n        isViewerFriend\r\n        profilePicture(size: 50){\r\n            uri\r\n            width\r\n            height\r\n        }\r\n        friendConnection(first: 5){\r\n            totalCount\r\n            friends {\r\n                id\r\n                name\r\n            }\r\n        }\r\n    }\r\n}\n서버측의 응답 역시 아래와 같이 클라이언트의 쿼리와 유사한 형태로 돌려받을 수 있습니다.\n{\r\n    \"data\": {\r\n        \"user\": {\r\n            \"id\": 333\r\n            \"name\": \"Peter\",\r\n            \"isViewerFriend\" : true,\r\n            \"profilePicture\": {\r\n            \t\"uri\" : \"cdn://kakaocdn.img.net/.....\",\r\n            \t\"width\": 25,\r\n            \t\"height\": 25\r\n        \t}\r\n        },\r\n    \t\"friendConnection\": {\r\n            \"totalCount\": 13,\r\n            \"friends\": [\r\n                {\r\n                    \"id\": \"1111\",\r\n                    \"name\": \"Hallen\"\r\n                },\r\n                {\r\n                    \"id\": \"2222\",\r\n                    \"name\": \"Jordan\"\r\n                }\r\n            ]\r\n        }\r\n    }\r\n}","단일-엔드-포인트#단일 엔드 포인트":"REST API 에서는 User 데이터와 Post 데이터를 가져올 때 두번의 API 호출이 일어납니다.\nGraphQL 을 사용할 경우에는 아래와 같이 단일 엔드포인트를 가지게 됩니다.","over-fetching-under-fetching-방지#over-fetching, under-fetching 방지":"Rest API 에 비해서 GraphQL 은 필요한 데이터만 가져오기 때문에 over-fetching, under-fetching 에 대해 단점이 보완됩니다.","타입-시스템-todo--그림추가---그림-그리는-것-스킵함#타입 시스템 (todo : 그림추가 - 그림 그리는 것 스킵함)":"GraphQL 은 타입시스템을 기반으로 데이터를 조회합니다.","graphql-의-schema---type-querymutation-directives#GraphQL 의 Schema - type, query,mutation, directives":"GraphQL 의 Schema 는 아래와 같은 요소들로 구성됩니다.\nType : 데이터의 형식(Type) 을 정의하는 데에 사용됩니다.\nQuery, Mutation : 조회(Query) 또는 수정(Mutation)에 사용됩니다.\nDirectives : 쿼리(Query), 뮤테이션(Mutation) 의 실행방식을 제어하는 Directive (지시자) 입니다.","graphql-의-type#GraphQL 의 type":"GraphQL 은 type 이라고 하는 것을 통해 데이터 형식을 정의합니다. GraphQL 은 스키마를 확장하고 수정하는 데에 유연한 구조를 갖습니다. 기존 타입에 필드를 추가하는 것 도 가능하며 기존 타입을 확장(extends)해서 새로운 타입을 생성하는 것 역시 가능합니다.\ntype User {\r\n    id: ID!\r\n    name: String!\r\n    email: String!\r\n}\r\n\r\ntype Query {\r\n    user(id: ID!): User\r\n    allUsers: [User!]!\r\n}\r\n\r\ntype Mutation {\r\n    createUser(name: String!, email: String!): User!\r\n    updateUser(id: ID!, name: String, email: String): User!\r\n\tdeleteUser(id: ID!): Boolean!\r\n}\ntype 은 아래와 같은 타입들이 있습니다.\nScalar Type (스칼라 타입) : 가장 기본적인 타입이며, 단일 값을 의미합니다.\ne.g. String, Int, Float, Boolean, ID\nObject Type (객체 타입) : 여러 가지 필드 들을 가지고 있는 객체 타입을 의미합니다.\nInterface Type (인터페이스 타입) : GraphQL 에서 공유되는 필드의 타입을 정의할 때 사용합니다.\nEnum Type (열거형 타입) : enum 타입을 의미합니다.\nUnion Type (유니온 타입) : 두개 이상의 여러 타입 중 하나일 수 있는 값을 의미합니다.\ne.g. union SearchResult = Product | Coupon\nInput Object Type (입력 객체 타입) : 입력 객체 타입은 쿼리, 뮤테이션의 입력 매개변수로 사용되는 복합타입을 의미합니다. 주로 쿼리, 뮤테이션 내의 매개변수로 전달되는 데이터의 구조를 정의할 때 사용합니다.\nList 타입\nList 는 배열 형태의 데이터를 의미하며 [String!]! 과 같이 [타입] 과 같은 표현식으로 표현 가능합니다.\nNon-Null 타입\nNon-Null 은 Null 을 허용하지 않는 타입을 의미하며 String! 과 같이 ! 으로 끝나는 타입을 의미합니다.","scalar#Scalar":"가장 기본적인 타입이며, 단일 값을 의미합니다. (e.g. String, Int, Float, Boolean, ID)","object#Object":"여러 가지 필드 들을 가지고 있는 객체 타입을 의미합니다.\ntype Profile{\r\n    userId: ID!\r\n    pictureUrl: String\r\n    birthday: Date\r\n    bio: String\r\n}\r\n\r\ntype User{\r\n    id: ID!\r\n    username: String!\r\n    email: String!\r\n    posts: [Post!]!\r\n\tprofile: Profile\r\n}","interface#Interface":"GraphQL 에서 공유되는 필드의 타입을 정의할 때 사용합니다. 인터페이스를 implements 하는 객체는 그 인터페이스의 모든 필드를 구현합니다.\ninterface Node {\r\n    id: ID!\r\n}\r\n    \r\ntype User implements Node{\r\n    id: ID!\r\n    username: String!\r\n    email: String!\r\n}\r\n\r\ntype Post implements Node{\r\n    id: ID!\r\n    title: String!\r\n    content: String!\r\n}","enum#Enum":"C++, Kotlin, Java 등의 언어에 존재하는 Enum 이라는 개념입니다.\nenum PaymentStatus{\r\n    PAYMENT_FAIL,\r\n    PG_API_CALL_FAIL,\r\n    PG_API_CALL_SUCCESS,\r\n    PAYMENT_COMPLETE\r\n}\r\n\r\ntype Order{\r\n    id: ID!\r\n    username: String!\r\n    payment_status: PaymentStatus\r\n}","union#Union":"두개 이상의 여러 타입 중 하나일 수 있는 값을 의미합니다.\nunion SearchResult = Product | Coupon","input-object-type#Input Object Type":"입력 객체 타입은 쿼리, 뮤테이션의 입력 매개변수로 사용되는 복합타입을 의미합니다. 주로 쿼리, 뮤테이션 내의 매개변수로 전달되는 데이터의 구조를 정의할 때 사용합니다.\ninput createUserInput {\r\n    username: String!\r\n    email: String!\r\n    password: String!\r\n    age: Int\r\n}\r\n\r\ntype Mutation {\r\n    createUser(input: createUserInput!): User!\r\n}","list--non-null-타입#List & Non-Null 타입":"List 는 배열 형태의 데이터를 의미하며 [String!]! 과 같이 [타입] 과 같은 표현식으로 표현 가능합니다.Non-Null 은 Null 을 허용하지 않는 타입을 의미하며 String! 과 같이 ! 으로 끝나는 타입을 의미합니다.\ntype User {\r\n    id: ID!\r\n    username: String!\r\n    emails: [String!]!\r\n\tposts: [Post]\r\n}","스키마-확장-todo-이-부분-조금-더--자료조사-필요#스키마 확장 (todo: 이 부분 조금 더  자료조사 필요)":"https://graphql-kr.github.io/learn/schema/\n새로운 기능을 추가하고 데이터 모델을 확장하기 위한 목적으로 확장을 사용합니다. 위에서 정리했듯 스키마에는 Type, Query, Mutation, Directives 가 있습니다. 스키마를 확장하는 방법은 아래의 두 방법이 있습니다.\n새로운 type 정의\n기존 type 확장","새로운-type-정의#새로운 type 정의":"예를 들어 현재 Schema 에 User 라는 type 이 없다면 새로 추가해줍니다.\ntype Mutation {\r\n    createUser(name: String!, email: String!) User!\r\n}\r\n\r\ntype User {\r\n    id: ID!\r\n    name: String!\r\n    email: String!\r\n}","기존-type-확장#기존 type 확장":"age 라는 필드가 새로 필요하면 어떻게 할까요? age 필드를 새로 추가하면 됩니다.\ntype Mutation {\r\n    createUser(name: String!, email: String!) User!\r\n}\r\n\r\ntype User {\r\n    id: ID!\r\n    name: String!\r\n    email: String!\r\n    age: Int // 이 부분입니다.\r\n}","사용자-정의-스키마-타입#사용자 정의 스키마 타입":"String, Int, Float, Boolean, ID 외의 특정 데이터 타입을 정의할 때 사용하는 타입을 의미합니다.","eg-날짜#e.g. 날짜":"GraphQLObjectType queryType = GraphQLObjectType.newObject()\r\n    .name(\"Query\")\r\n    .field(field -> field\r\n           .name(\"date\")\r\n           .type(ExtendedScalars.Date)\r\n           .dateFetcher(environment -> \"2024-06-08\"))\r\n    .build();","eg-이메일#e.g. 이메일":"GraphQLObjectType queryType = GraphQLObjecttype.newObject()\r\n    .name(\"Query\")\r\n    .field(field -> field\r\n          .name(\"email\")\r\n          .type(ExtendedScalars.Email)\r\n          .dataFetcher(environment -> \"example@example.com\"))\r\n    .build();","eg-사용자-정의-스키마-타입-custom-scalar-type#e.g. 사용자 정의 스키마 타입 (Custom Scalar Type)":"public class CustomDateScalar {\r\n    public static GraphQLScalarType dateScaler = GraphQLScalarType.newScalar()\r\n        .name(\"Date\")\r\n        .description(\"Date Scalar Type\")\r\n        .coercing(new Coercing <LocalDate, String>(){\r\n            @Override\r\n            public String serialize(Object dateFetcherResult) throws CoercingSerializeException {\r\n                if(dateFetcherResult instanceof LocalDate){\r\n                    return ((LocalDate) dataFetcherResult).format(DateTimeFormatter.ISO_DATE);\r\n                }\r\n                throw new CoercingSerializeException(\"Invalid value for Date Scalar\")\r\n            }\r\n            \r\n            @Override\r\n            public LocalDate parseValue(Object input) throws CoercingParseValueException{\r\n                try{\r\n                    return LocalDate.parse(input.toString(), dateTimeFormatter.ISO_DATE);\r\n                }\r\n                catch(Exception e){\r\n                    throw new CoercingParseValueException(\"Invalid input for Date Scalar\");\r\n                }\r\n            }\r\n            \r\n            @Override\r\n            public LocalDate parseLiteral(Object input) throws CorercingParseLiteralException {\r\n                try{\r\n                    return LocalDate.parse(input.toString(), DateTimeFormatter.ISO_DATE);\r\n                }\r\n                catch (Exception e){\r\n                    throw new CoercingParseLiteralException(\"invalid literal for date scalar\");\r\n                }\r\n            }\r\n        }).build();\r\n}","graphql-쿼리#GraphQL 쿼리":"","graphql-쿼리-구성-요소#GraphQL 쿼리 구성 요소":"","resolver-의-종류#Resolver 의 종류":"","datafetcher#DataFetcher":"","dataloader#DataLoader":"","graphql-resolver-사용시-유의사항#GraphQL Resolver 사용시 유의사항":""}}}